# -*- coding: utf-8 -*-
# (c) 2025 OpenHands
#
# Module for creating and managing 'Code Features' in FreeCAD,
# which are Part::Features driven by Python code (CadQuery or Build123D).

import FreeCAD
import Part

def create_code_feature(doc, name="CodeFeature"):
    """
    Creates a new 'Code Feature' (a Part::Feature with custom properties for storing code).

    Args:
        doc: The FreeCAD document to add the feature to.
        name (str): The name for the new feature.

    Returns:
        The newly created FreeCAD feature object, or None if creation fails.
    """
    if not doc:
        FreeCAD.Console.PrintError("No active document to add CodeFeature.\\n")
        return None

    obj = doc.addObject("Part::Feature", name)
    if not obj:
        FreeCAD.Console.PrintError(f"Failed to create Part::Feature with name {name}.\\n")
        return None

    # Add custom properties
    # Property to store the Python code string
    obj.addProperty("App::PropertyString", "CodeString", "CodeObject", "Python code (CadQuery/Build123D) to generate the shape.")
    
    # Property to store the type of code
    obj.addProperty("App::PropertyEnumeration", "CodeType", "CodeObject", "The type of code used (CadQuery or Build123D).")
    obj.CodeType = ["CadQuery", "Build123D"] # Set the available options for the enumeration

    # Property to store a label for the generated object (used by show_object)
    obj.addProperty("App::PropertyString", "GeneratedObjectLabel", "CodeObject", "Optional label for the object generated by the code.")

    # Initialize properties with default values
    obj.CodeString = \"\"\"
import cadquery as cq

# Default cube
result = cq.Workplane("XY").box(10, 10, 10).val()
# The last expression assigned to 'result' will be used as the shape.
\"\"\"
    obj.CodeType = "CadQuery" # Default to CadQuery
    obj.GeneratedObjectLabel = name # Default label for the generated part

    FreeCAD.Console.PrintMessage(f"Created CodeFeature: {obj.Name} with Label {obj.Label}\\n")
    doc.recompute() # Recompute to make the new object visible and properties available
    return obj

# --- Placeholder for execution logic ---
def execute_code_feature(feature_object):
    \"\"\"
    Executes the code stored in the CodeFeature and updates its Shape.
    (This is a simplified placeholder - full implementation needs care with execution context and error handling)
    \"\"\"
    if not hasattr(feature_object, "CodeString") or not hasattr(feature_object, "CodeType"):
        FreeCAD.Console.PrintError(f"Object {feature_object.Name} is not a valid CodeFeature.\\n")
        return

    code_string = feature_object.CodeString
    code_type = feature_object.CodeType
    generated_object_label = feature_object.GeneratedObjectLabel if hasattr(feature_object, "GeneratedObjectLabel") else feature_object.Name

    FreeCAD.Console.PrintMessage(f"Executing CodeFeature: {feature_object.Name} (Type: {code_type})\\n")

    # Prepare a local scope for exec
    local_scope = {}
    
    # Import necessary modules into the scope
    if code_type == "CadQuery":
        try:
            import cadquery as cq
            local_scope['cq'] = cq
        except ImportError:
            FreeCAD.Console.PrintError("CadQuery module not found. Please install it.\\n")
            return
    elif code_type == "Build123D":
        try:
            import build123d as b3d # Common alias
            local_scope['b3d'] = b3d
            # build123d might also need specific imports like Shape, Workplane, etc.
            # For simplicity, we'll assume the user script handles its own b3d imports for now,
            # or we can add more common ones here.
            from build123d import export_brep # Needed for converting to FreeCAD shape
            local_scope['export_brep'] = export_brep

        except ImportError:
            FreeCAD.Console.PrintError("Build123D module not found. Please install it.\\n")
            return
    else:
        FreeCAD.Console.PrintError(f"Unknown code type: {code_type}\\n")
        return

    # Add a variable to hold the result
    local_scope['result'] = None 

    try:
        # Execute the user's code
        # For safety, consider using a more restricted environment if this code can be arbitrary
        exec(code_string, {"__builtins__": __builtins__}, local_scope)
        
        generated_shape_val = local_scope.get('result')

        if generated_shape_val is None:
            FreeCAD.Console.PrintError("No 'result' variable found in the executed code. Make sure your script assigns the final shape to a variable named 'result'.\\n")
            return

        # Convert the resulting CadQuery/Build123D object to a FreeCAD Part.Shape
        # This part reuses logic similar to the existing display.py
        import Part
        from io import BytesIO
        brep_stream = BytesIO()

        if code_type == "CadQuery":
            if isinstance(generated_shape_val, cq.Workplane):
                generated_shape_val.val().exportBrep(brep_stream)
            elif isinstance(generated_shape_val, cq.Shape):
                generated_shape_val.exportBrep(brep_stream)
            else:
                FreeCAD.Console.PrintError(f"CadQuery script resulted in an unsupported type: {type(generated_shape_val)}\\n")
                return
        elif code_type == "Build123D":
            # build123d objects might be wrapped or direct OCP shapes.
            # The export_brep function from build123d should handle this.
            try:
                # Assuming 'export_brep' is available in local_scope from import
                local_scope['export_brep'](generated_shape_val, brep_stream)
            except Exception as e:
                FreeCAD.Console.PrintError(f"Error exporting Build123D shape: {e}\\n")
                return
        
        brep_string = brep_stream.getvalue().decode('utf-8')
        if not brep_string:
            FreeCAD.Console.PrintError("Failed to generate BRep string from the code result.\\n")
            return
            
        part_shape = Part.Shape()
        part_shape.importBrepFromString(brep_string)

        if part_shape.isNull():
            FreeCAD.Console.PrintError("Resulting Part.Shape is null. Check the code and BRep export.\\n")
            return

        feature_object.Shape = part_shape
        if hasattr(feature_object.ViewObject, "ShapeColor"): # Check if ViewObject exists and has ShapeColor
             # You can set default color or expose as property later
            pass # feature_object.ViewObject.ShapeColor = (0.8, 0.8, 0.3) 
        if hasattr(feature_object.ViewObject, "Transparency"):
            pass # feature_object.ViewObject.Transparency = 0

        # Update the label of the feature if a GeneratedObjectLabel was provided
        # The main feature name (obj.Name) is system-managed and should not be changed lightly.
        # The feature label (obj.Label) is user-friendly.
        if generated_object_label:
            feature_object.Label = generated_object_label

        FreeCAD.Console.PrintMessage(f"Successfully updated shape for {feature_object.Name} from code.\\n")

    except Exception as e:
        import traceback
        FreeCAD.Console.PrintError(f"Error executing CodeFeature '{feature_object.Name}':\\n{code_string}\\n------\\n{traceback.format_exc()}\\n")

    finally:
        if FreeCAD.ActiveDocument: # Ensure doc is still valid
            FreeCAD.ActiveDocument.recompute()

# Example of how to use it from the FreeCAD Python console:
# import CodeFeature
# doc = FreeCAD.activeDocument()
# if not doc:
#     doc = FreeCAD.newDocument("MyCodeFeatures")
# cf = CodeFeature.create_code_feature(doc, name="MyParametricCube")
# if cf:
#     # To change the code:
#     # cf.CodeString = "import cadquery as cq\\nresult = cq.Workplane('XY').sphere(5).val()"
#     # cf.CodeType = "CadQuery"
#     # cf.GeneratedObjectLabel = "MySphere"
#     # CodeFeature.execute_code_feature(cf)
#     #
#     # For Build123D:
#     # cf.CodeString = "from build123d import *\nresult = Sphere(10)" # Build123D often uses direct class instantiation
#     # cf.CodeType = "Build123D"
#     # cf.GeneratedObjectLabel = "MyB3DSphere"
#     # CodeFeature.execute_code_feature(cf)
#     pass

# To make this runnable from FreeCAD's macro system or workbench,
# you'd typically wrap these calls in Command classes.

def register_code_feature_command():
    \"\"\"
    Registers a command in FreeCAD to create a CodeFeature.
    This is a basic example; a real implementation would integrate into the CadQuery workbench menu.
    \"\"\"
    class CreateCodeFeatureCommand:
        def GetResources(self):
            return {"MenuText": "Create Code Feature",
                    "ToolTip": "Creates a new feature driven by CadQuery/Build123D code."}

        def Activated(self):
            doc = FreeCAD.activeDocument()
            if not doc:
                doc = FreeCAD.newDocument("CodeFeatureDoc")
            
            # Ask user for a name (optional, can be improved with a dialog)
            feature_name, ok = QtGui.QInputDialog.getText(FreeCADGui.getMainWindow(), 
                                                          "Create Code Feature", 
                                                          "Enter feature name:", 
                                                          QtGui.QLineEdit.Normal, 
                                                          "MyCodeObject")
            if ok and feature_name:
                new_feature = create_code_feature(doc, name=feature_name)
                if new_feature:
                    # Automatically execute once after creation to generate initial shape
                    execute_code_feature(new_feature) 
                    FreeCAD.ActiveDocument.recompute() # Ensure UI update
            else:
                FreeCAD.Console.PrintMessage("Code Feature creation cancelled by user.\\n")


        def IsActive(self):
            return True

    if FreeCAD.GuiUp: # Only register if GUI is running
        from PySide import QtGui # Import here as FreeCADGui might not be fully available at module load
        import FreeCADGui
        FreeCADGui.addCommand('CQ_CreateCodeFeature', CreateCodeFeatureCommand())

# Call registration when module is loaded in GUI environment
# if FreeCAD.GuiUp:
#    register_code_feature_command() # This should be called from InitGui.py of the workbench

def recompute_selected_code_feature_command():
    \"\"\"
    Registers a command to recompute the selected CodeFeature.
    \"\"\"
    class RecomputeCodeFeatureCommand:
        def GetResources(self):
            return {"MenuText": "Recompute Code Feature",
                    "ToolTip": "Re-executes the code for the selected Code Feature."}

        def Activated(self):
            selection = FreeCADGui.Selection.getSelection()
            if not selection:
                FreeCAD.Console.PrintWarning("No object selected to recompute.\\n")
                return
            
            recomputed_any = False
            for obj in selection:
                if hasattr(obj, "Proxy") and isinstance(obj.Proxy, CodeFeatureProxy): # Check if it's our specific kind of feature
                     execute_code_feature(obj)
                     recomputed_any = True
                elif hasattr(obj, "CodeString") and hasattr(obj, "CodeType"): # Fallback check for properties
                    FreeCAD.Console.PrintMessage(f"Attempting to recompute generic object {obj.Label} as Code Feature.\\n")
                    execute_code_feature(obj)
                    recomputed_any = True

            if not recomputed_any:
                 FreeCAD.Console.PrintWarning("No selected object appears to be a Code Feature that can be recomputed this way.\\n")


        def IsActive(self):
            selection = FreeCADGui.Selection.getSelection()
            if not selection: return False
            # Only active if at least one selected object looks like a CodeFeature
            for obj in selection:
                if (hasattr(obj, "Proxy") and isinstance(obj.Proxy, CodeFeatureProxy)) or \
                   (hasattr(obj, "CodeString") and hasattr(obj, "CodeType")):
                    return True
            return False

    if FreeCAD.GuiUp:
        import FreeCADGui
        FreeCADGui.addCommand('CQ_RecomputeCodeFeature', RecomputeCodeFeatureCommand())

# if FreeCAD.GuiUp:
#    recompute_selected_code_feature_command() # This should be called from InitGui.py

# --- FreeCAD FeaturePython structure (if we were to make it a full FeaturePython object) ---
# This part is more advanced and makes the feature behave more like a native FreeCAD feature,
# with its own icon, properties in the tree, and recomputation logic.
# For now, we are using a simpler approach of adding properties to a Part::Feature.
# If a more integrated solution is needed, this is the direction to go.

class CodeFeatureProxy:
    \"\"\"
    A proxy class to be used if we make CodeFeature a full FeaturePython object.
    This class handles the logic of the feature, especially recomputation.
    \"\"\"
    def __init__(self, obj):
        \"\"\"
        Constructor. obj is the FreeCAD object that this proxy is attached to.
        \"\"\"
        self.Object = obj
        obj.Proxy = self
        # obj.addProperty("App::PropertyString", "CodeString", "CodeObject", "Python code...").CodeString = "..."
        # obj.addProperty("App::PropertyEnumeration", "CodeType", "CodeObject", "...").CodeType = ["CadQuery", "Build123D"]
        # etc. - properties would be defined here or by the C++ feature if it's a derived one.

    def execute(self, fp):
        \"\"\"
        Called by FreeCAD when the feature needs to be recomputed.
        fp is the feature object itself (same as self.Object).
        \"\"\"
        FreeCAD.Console.PrintMessage(f"CodeFeatureProxy.execute for {fp.Label}\\n")
        # This is where execute_code_feature would be called
        execute_code_feature(fp)
        return True

    def onChanged(self, fp, prop):
        \"\"\"
        Called when a property of the feature changes.
        \"\"\"
        FreeCAD.Console.PrintMessage(f"Property '{prop}' of {fp.Label} changed.\\n")
        # If CodeString or CodeType changes, we might want to trigger a recompute.
        # However, FreeCAD usually handles recomputation based on property changes affecting the shape.
        # For non-Output properties, explicit recompute might be needed if they influence the shape.
        if prop == "CodeString" or prop == "CodeType" or prop == "GeneratedObjectLabel":
            # Forcing a recompute might be too aggressive here,
            # FreeCAD's recompute mechanism should pick it up if Shape is touched by execute().
            # self.execute(fp) # Or mark as touched: fp.touch()
            pass


# To make this a full FeaturePython object, you would do something like:
# def create_true_code_feature(doc, name="TrueCodeFeature"):
#    obj = doc.addObject("Part::FeaturePython", name)
#    CodeFeatureProxy(obj) # Attach the proxy
#    obj.ViewObject.Proxy = 0 # Can also have a ViewProviderProxy for custom display
#    # Add properties directly here or ensure CodeFeatureProxy adds them
#    obj.addProperty("App::PropertyString", "CodeString", "CodeObject", "Python code...")
#    obj.CodeString = "import cadquery as cq\\nresult = cq.Workplane('XY').box(1,2,3).val()"
#    obj.addProperty("App::PropertyEnumeration", "CodeType", "CodeObject", "Code Type")
#    obj.CodeType = ["CadQuery", "Build123D"]
#    obj.CodeType = "CadQuery"
#    doc.recompute()
#    return obj

# This file needs to be imported by the workbench's InitGui.py to register commands
# and potentially by Init.py if it's defining non-GUI aspects of features.
